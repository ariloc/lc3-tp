\documentclass[a4paper, titlepage]{report}

\usepackage[T1]{fontenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{caption,subcaption}
\usepackage{hyperref, url}

\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}

\title{
	\textsc{\Large{}\raggedleft{Instalación y Reemplazo de Componentes Internos}}\\
		 \vspace{18pt}
		\fontsize{40}{40}{\textbf{\texttt{LC-3}}}\\
		\Huge\textbf{\textit{Un lenguaje de bajo nivel}}
\vspace{-10pt}
}
\author{\Large{}Ariel Leonardo Fideleff}
\date{junio de 2022}

\begin{document}
	\pagenumbering{gobble}
	\maketitle
	
	\pagenumbering{arabic}
	\thispagestyle{plain}
	\tableofcontents
	
	\chapter{Introducción}
	
	\section{¡Bienvenido al bajo nivel!}
	
	\textit{¡Bienvenido al bajo nivel!}... pero paremos un segundo, ¿qué es el \textit{bajo nivel}? ¿De qué estamos hablando? Si hay un bajo nivel, también debe haber un \textit{alto nivel}, no? ¿Cómo tiene que ver todo esto con la programación?
	
	La verdad es que si bien podríamos estar ya mismo empezando a explicar un programa de ejemplo en \texttt{LC-3}, hay varios conceptos que probablemente tengamos que aclarar sobre el funcionamiento de las computadoras y algo de terminología.
	
	Ya sabemos... probablemente piensan que es aburrido. Pero creemos que si entienden algunos de estos conceptos, puedan también comprender el motivo de las limitaciones y desafíos que conlleva programar con lenguajes de bajo nivel, y del proceso lógico que lleva hacer programas en, concretamente, \texttt{LC-3}. 
	
	\section{Desde el \textit{hardware}}
	
	¿Alguna vez se preguntaron cómo un procesador formado por millones diminutos transistores de silicio es capaz de correr el juego que tanto les gusta? Si alguno se quedó en la parte de \textit{millones de transistores}, simplemente vean la imagen en la figura \ref{fig:die-img} que muestra la estructura interna de un procesador moderno.
	
	\begin{figure}[h]
		\centering
		\captionsetup{justification=centering}
		\includegraphics[width=.6\linewidth]{i9-die.jpg}
		\caption{Los millones de transistores que componen un procesador moderno, en este caso el Intel Core i9-12900K}
		\label{fig:die-img}
	\end{figure}

	No se fijen tanto en los colores, su propósito es fundamentalmente distinguir la densidad de transistores en un área determinada.
	
	A lo que apuntamos es que se empiecen a preguntar sobre todo el proceso que conlleva partir desde pulsos eléctricos, a los usos que le damos en el día a día a las computadoras (ya sea en el formato de torre de escritorio, una notebook, o un celular).
	
	Con esto en cuenta, es desde esa placa de silicio que parte todo. Todos los programas que forman el \textit{software} deben de correr en un \textit{hardware} que sea capaz de soportarlos. Y un procesador es \textit{literalmente} una parte central en un sistema de computadora\footnote{Lo entienden? CPU? \textbf{Central} Processing Unit? sigh...}.
	
	Nuestra tarea como programadores de bajo nivel es tener algunas nociones sobre el funcionamiento del hardware, con el fin de luego hacer uso de ese conocimiento, para poder confeccionar software que sea capaz de transmitirle correctamente las instrucciones necesarias para ejecutar las tareas que queramos realizar. 
	
	\section{El \texttt{ISA} y elementos de una computadora}
	
	Ya se van a dar cuenta que una de las cosas que más les gusta a los informáticos es ponerle abreviaturas a todas las cosas, más aún si nos referimos a cosas complejas con nombres largos y difíciles de recordar. Sin embargo, siempre traten de entender al menos qué es de lo que están hablando, antes que usar las abreviaturas por el resto de su vida.
	
	\subsection{El set de instrucciones}
	
	Cuando hablamos de procesadores, si bien, por ejemplo, te pueden vender la cantidad de núcleos que tienen, a nosotros nos interesa más saber que un procesador maneja tareas tales como el manejo de operaciones lógicas y matemáticas, como también el manejo de la entrada y la salida de información (conocida típicamente como \texttt{I/O}, de \textit{Input/Output} en inglés).
	
	Estas tareas son posibles a partir del \textbf{set de instrucciones} que el procesador es capaz de entender y llevar a cabo. \\
	
	Una de las cosas más difíciles al enseñar programación, es transmitir cómo uno debe desglosar en pequeñas subtareas, aquello que alguien normalmente hace intuitivamente en una hoja de papel. Por ejemplo, si nos dicen de hacer un programa en \texttt{C} para contar la cantidad de números impares en un arreglo de números, hay que pensar en cada uno de los pasos que hacemos si nos dieran el mismo problema para hacer con papel y lápiz. Así nos daremos cuenta que en nuestra cabeza, rápidamente \textit{iteramos} por cada uno de los números de la lista mientras los leemos, verificando en cada caso la condición pedida, y luego transmitimos un resultado, ya sea de forma escrita o hablada.
	
	Por lo tanto, a la hora de diseñar un procesador, el objetivo es incluir un conjunto de tareas o \textit{instrucciones} elementales, que combinadas brinden la flexibilidad necesaria para realizar cualquier tarea que queramos que una computadora lleve a cabo.
	
	Así, el \textit{set de instrucciones} de un procesador abarca las distintas instrucciones que es capaz de comprender, y que están resueltas a nivel del hardware. Estas operaciones, como dijimos, se relacionan con operaciones matemáticas (suma, multiplicación), como también con I/O (lectura y escritura en memoria, acceso a registros).
	
	\subsection{¿Y la definición?}
	
	De todas formas, probablemente habrán notado que todavía no definimos el significado de \texttt{ISA}, y eso que habíamos dicho que no había que abusar de las abreviaturas.
	
	El \textbf{Instruction Set Architecture} define un modelo abstracto fundamental de una computadora, y nos da la información de los elementos que tenemos a disposición como programadores para que nuestro software pueda interactuar con el hardware definido por una arquitectura. Para que quede claro, la arquitectura es, a modo general, el diseño de cómo va a funcionar la computadora: la interacción entre sus distintos componentes, las reglas que lo rigen y su implementación (es decir, cómo lo llevamos a cabo en un escenario real).
	
	En términos simples, el ISA especifica la parte de la arquitectura sobre qué es lo que se encuentra a disposición del programador para poder decirle a la computadora qué es lo que tiene que hacer. Es por esto que antes habíamos introducido el concepto del set de instrucciones, ya que es una de las partes principales del ISA. Reiteramos, es \textit{una de las partes principales}, pero esto no implica que sea todo.\\
	
	\subsection{¿Cómo nos llega la información?}
	
	Ya veremos que una de las instrucciones de \texttt{LC-3} es \texttt{ADD}, el cual uno puede asumir que sirve para sumar dos números. Ahora bien, pensá que un amigo te dice literalmente ``\textit{sumá dos números}''. Lo primero que uno responde es, ``\textit{¿qué números?}''. Entonces te apunta a una hoja de papel, desde la cual tenés que leer los números.
	
	Observar que tenemos que saber cómo manejar una hoja de papel para poder leer la información en ella. Podrá parecer trivial, pero es que intuitivamente sabemos cómo agarrar una hoja de papel, y disponerla frente a nuestros ojos para leer lo que esté allí escrito. Y una vez la tenemos frente a nuestros ojos, sabemos cómo interpretar lo que vemos de una forma que nuestro cerebro lo pueda comprender.
	
	Esto ilustra que las operaciones de por sí no son suficientes para que una computadora sepa lo que tiene qué hacer. De hecho, básicamente estaríamos ignorando completamente la definición de ``informática'', que entre tantas cosas abarca al \textit{conjunto de técnicas para el procesamiento, almacenamiento y transmisión de la información}. Necesitamos que la computadora sepa \textit{cómo leer} la información, así también \textit{cómo devolverla}. Por lo tanto, el ISA especifica también la forma en la que se ingresa y se presenta la información procesada al sistema, el I/O ya mencionado.
	
	La respuesta simple a la pregunta en el caso de una computadora es bueno, a través de \textit{pulsos eléctricos}. Pero... ¿cómo se ingresan esos pulsos eléctricos? ¿cómo se interpretan? ¿definen algún patrón? Las preguntas concretas sobre cómo implementarlo se las dejamos a los encargados de diseñar la arquitectura y el hardware, pero como programadores nos interesa la especificación de instrucciones que nos permitan leer y mostrar información, es decir, saber cómo usar las instrucciones que nos habilitan el I/O.
	
	En el caso de nuestro ejemplo, tenemos que tener las ``instrucciones'' para que nos digan cuando se quiere, por ejemplo, leer de un papel, y que sepamos hacerlo.
	
	\subsection{¿Cómo guardamos la información?}
	
	Una vez que pudimos leer la información, debemos de tenerla guardada en algún lugar para poder operar con ella. Esto introduce otro componente importante de una computadora, la \textbf{memoria}.
	
	En nuestro ejemplo nos dan una hoja de papel donde podemos decir que ``están almacenados'' los números, así que lo podemos considerar como un ejemplo de memoria, no? No hay que confundir la memoria con \textit{medios de almacenamiento}. De ahora en más, cuando hablemos de memoria, siempre haremos referencia a sistemas o dispositivos que nos permitan almacenar información \textbf{para su uso inmediato}.
	
	Mírenlo de esta forma: es más rápido sumar dos números cuando los tenemos ya en nuestra cabeza, que si estamos constantemente leyéndolos del papel. La memoria en este caso es nuestra capacidad de recordar los números con los que operamos, y el papel es un medio de almacenamiento que nos permite resguardar los números a largo plazo. Análogamente, esto se relaciona en cómo es más rápido leer de la memoria RAM, que de un medio de almacenamiento como un disco duro HDD o hasta un disco de estado sólido SSD.\\
	
	Dicho esto, para operar con los números, es necesario tener alguna forma de que los números permanezcan en nuestra cabeza, al menos de forma temporal. Si queremos hacer $2+2$, tenemos que acordarnos, por más que sea por fracciones de segundo, de los dos números, para saber e informar que el resultado de la operación es $4$. Así, es que el ISA define también cómo podemos acceder a la memoria, cómo podemos operar con ella, y las instrucciones relacionadas.\\
	
	En las computadoras hay distintos tipos de memoria que ocupan distintos lugares en una jerarquía que depende según su velocidad, aunque trataremos estas diferencias más adelante cuando definamos en detalle el ISA de \texttt{LC-3}.
	
	Nomás tengan en cuenta que cuando hablamos de ``memoria'' muchas veces no sólo nos referimos, como ya habíamos aclarado, a memorias de uso inmediato, sino concretamente a memorias volátiles (que no permiten almacenar información a largo plazo y que se borran cuando, por ejemplo, se les quita energía) a las cuales podemos acceder a sus contenidos de forma aleatoria (modificar y acceder a distintas partes de la memoria rápidamente). Hoy en día, este tipo de memorias las conocemos como \textit{memorias RAM} (Random Access Memory, en español, memorias de acceso aleatorio).
	
	Créannos que a lo largo de este texto se les va a ir aclarando de lo que estamos hablando.
	
	\subsection{¿La operación se guarda?}
	
	Entonces ya sabemos leer los números, guardarlos, hacer la operación, y devolver el resultado. ¿Nos falta algún paso más?
	
	En vez de dar una respuesta, vamos a proponer otra pregunta: ¿La operación dónde está guardada? Dicho de otra forma, ¿de dónde lee la computadora la operación?
	
	La respuesta lógica a esta pregunta es que la operación se encuentra en un programa, y ese programa necesariamente tiene que estar en la memoria. Al fin y al cabo, el programa es con el cual estamos haciendo operaciones en el uso inmediato.
	
	Pero en la memoria también habíamos guardado los números una vez los habíamos leído. Esto nos lleva a la pregunta: ¿cómo distinguimos la memoria en dónde está nuestro programa, con la memoria de la información que leímos?
	
	Tantas preguntas y pocas respuestas...\\
	
	Cuando queremos acordarnos de alguna cosa, generalmente sólo ``lo pensamos'' y con suerte nos acordamos y podemos utilizar la información obtenida. Si bien los científicos podrán no saber con exactitud todavía cómo funciona este proceso, mientras tanto tenemos que tener alguna forma de diseñar una memoria que nos permita acceder a los distintos fragmentos de información que contiene de una forma ordenada. Es por esto que la memoria tiene \textbf{direcciones de memoria}, que funcionan como identificadores para cada uno de los sectores de la memoria que podemos acceder de forma independiente según nuestras necesidades. 
	
	Notar que cada dirección de memoria se corresponde con una cantidad fija de espacio. Es decir, es como si dividiéramos la memoria en millones de pedazos iguales, y que cada uno de ellos sea accesible por una dirección de memoria. Típicamente en las computadoras de hoy en día, cada uno de estos pedazos tiene el tamaño de 1 \textit{byte}, el equivalente a 8 \textit{bits}. De todas formas, veremos que en el caso de \texttt{LC-3}, la memoria es ``16-bit addressable'', es decir, que cada pedazo tiene 16 bits.
		
	Para el que se encuentre perdido en este sentido, probablemente hayan visto que los archivos en la computadora tienen un determinado tamaño. Un documento de texto tiene un tamaño en el orden de los \textit{kilobytes}, una imagen en el orden de los \textit{megabytes}, y una película probablemente en el orden de los \textit{gigabytes}. Son todas unidades de escala basadas en los bytes. Y para que sepan, cada bit es literalmente un 0 o un 1, por lo que si hablamos de 12 kilobytes (kB), es lo mismo que decir $12 * 1000 = 12\,000$ bytes, también equivalente a $12.000 * 8 = 96\,000$ bits, o sea, un conjunto de $96\,000$ 0s y 1s. No confundir los kilobytes con los $kibibytes$, esos se multiplican por $1024$ cada paso, en vez de por $1000$.\\
	
	Igual nos estamos yendo del tema. A lo que vamos es que la memoria está dividida en pedazos para que podamos accederla y modificarla fácilmente. Si bien hablamos de archivos para ilustrar la idea de los tamaños, estos ocupan espacio en un medio de almacenamiento, el cual ya habíamos diferenciado de la memoria. Comúnmente los programas se encuentran almacenados  en medios de almacenamiento no volátiles (justamente, por ejemplo, un disco duro), y a la hora de ejecutarlos se cargan en memoria, que es de uso inmediato.
	
	Al cargarse el programa en memoria podemos saber las direcciones que ocupa, como también las direcciones en las cuales se leyó la información a procesar, en este caso, los números a sumar. Así, una de las piezas que nos falta para resolver nuestro problema, es cómo indicarle al programa en qué parte de la memoria se encuentran los números ingresados. Estas distintas formas de indicar direcciones de memoria en el programa, se las llama \textbf{addressing modes} (en español, \textit{modos de direccionamiento}, y también se encuentran especificados en el ISA.
	
	De forma simplificada, podríamos decir que la información se encuentra a una cierta cantidad de direcciones de memoria de distancia desde la ubicación de la instrucción en memoria, como también podríamos especificar concretamente la dirección de memoria de forma absoluta. Todo dependerá del contexto con el que estemos trabajando en nuestro programa. Más adelante veremos los addressing modes de los cuales disponemos con \texttt{LC-3}.
	
	\subsection{¿De qué forma tengo que entender esos 1s y 0s?}
	
	Ya sabemos que se está haciendo largo. No se preocupen, ya casi estamos terminando. Al menos les sirve para entender lo compleja que es una computadora, sin mencionar que estamos simplificando el proceso para que sea más ameno y fácil de entender.\\
	
	Una vez que el programa sabe en qué lugar de la memoria encontrar los números con los cuales operar, afortunadamente y como ya mencionamos, es común que exista una instrucción para poder sumar dos números. Sin embargo, ¿cómo sabe el programa cómo interpretar esos números?
	
	Otra cosa que nos parece intuitiva es que el símbolo \textit{6} represente el número dicho. Aunque también sabemos que \textit{seis} representa lo mismo. Y en números romanos, sucede con \textit{VI} de igual forma.
	
	De la misma forma que tenemos varias maneras de hablar de lo mismo, también es así con las computadoras. Nuevamente, los \textbf{data types} (\textit{tipos de datos}, en español) están también definidos en el ISA, y haremos uso de ellos según nos sea más conveniente. Un tipo de dato común en programación es la representación de los números en \textit{binario}, lo cual naturalmente se da por lo que ya venimos explicando, que los procesadores están compuestos de transistores, y que su estado de encendido o apagado representa un 1 o un 0 respectivamente. También la representación de la información como conjuntos de bits en la memoria, y en general el uso de lógica binaria a lo largo de un sistema de computadora facilita las distintas tareas como programadores.\\
	
	Para el caso de \texttt{LC-3}, veremos que sólo tenemos a disposición una única forma de representar los datos: como enteros en \textbf{complemento a 2}. Debido a que por ahora no entraremos en los detalles, podemos asumir para nuestro problema que la instrucción de suma que usaremos, ya sabe cómo están representados los números a sumar en la memoria.
	
	\subsection{Pasando en limpio}
	
	Tras explicar todas las distintas partes (a modo general) que forman parte del proceso para que una computadora pueda hacer una tarea que nos puede parecer tan básica como sumar dos números, intentaremos resumir lo que aprendimos, para continuar con las ideas claras.\\
	
	En resumen:
	
	\begin{itemize}
		\item La operación de suma se encuentra como una instrucción en un programa el cual se carga en la memoria, ubicándose en un conjunto de direcciones de memoria.
		\item El programa debe de contener, y hacer uso, de las instrucciones necesarias para leer los números, y almacenarlos en otras posiciones en la memoria.
		\item Al guardarse los números, éstos quedan representados con un determinado tipo de dato, el cual el programa tiene que tener en cuenta a la hora de hacer la operación.
		\item Así, a la instrucción de suma se le indican dónde se encuentran los números guardados mediante un modo de direccionamiento, el cual apunta a las direcciones correspondientes de memoria. La operación es capaz de entender la forma en la cual aquellos números se encuentran allí representados.
		\item Tras ejecutar la instrucción de suma, el resultado debe ser almacenado en otro lugar de la memoria.
		\item Finalmente, debe de indicarse la ubicación del resultado antes obtenido, para que éste sea informado al usuario mediante un dispositivo de salida adecuado, con las instrucciones correspondientes para este propósito.
	\end{itemize}

	Así parece más sencillo, ¿no? Con esta idea aproximada del proceso, esperamos que puedan seguirnos mejor mientras exploramos las particularidades de \texttt{LC-3}, su ISA y los programas que estaremos desarollando para este \textit{lenguaje de bajo nivel}.

	\section{Una vez más, ¿qué significa \textit{alto} y \textit{bajo} nivel?}
	
	Volvemos a la pregunta del comienzo del capítulo, para resolver de una vez la incógnita: \textbf{¿qué es un \textit{lenguaje} de bajo nivel?}
	
	Para que se sientan más familiares con lo que vamos a hablando, vamos a estar comparando o relacionando lo que expliquemos con el lenguaje \texttt{C}, el cual ya probablemente conocen por su trayecto en la escuela. Al fin y al cabo, es más sencillo partir desde lo que ya saben, que explicar todo desde cero.\\
	
	Capaz una forma distinta de pensarlo, sin dar muchas vueltas más es:
	
	\begin{center}
		\textit{¿por qué necesitamos ahora saber todo esto de sobre cómo funciona una computadora, y lo ignorábamos cuando programábamos en \texttt{C}?}
	\end{center}
	
	Primero y principal, capaz sería muy agobiante dar todo esto en 3er año. Además, la idea es dar esto a quienes eligieron la especialidad y a los cuales esta información sea relevante si luego pretenden desempeñarse como Técnicos en Informática Personal y Profesional.
	
	Pero más allá de los detalles del cursado, en la pregunta precisamente radica la diferencia entre un lenguaje de bajo nivel, y uno de alto nivel.
	
	\section{Felicitaciones, se ahorró más de 150 páginas de lectura}

	La realidad es que mucha información se perdió entre medio, pero nos enfocamos en lo necesario para continuar con el próximo capítulo.
	
	\chapter{Bibliografía} % extender y armar bien posta
	
	\begin{itemize}
		\item \url{https://www.techpowerup.com/review/intel-core-i9-12900k-alder-lake-12th-gen/2.html}
		\item \url{https://www.gamersnexus.net/guides/833-reading-a-cpu-die}
		\item Introduction to Computer Systems, Patt \& Patel % extender y armar bien
	\end{itemize}
	
\end{document}